{{ define "main" }}
<main class="photos content" aria-label="Foto-Archiv">
  <style>
    :root{
      --safe-top: env(safe-area-inset-top, 0px);
      --badge-margin: 0.9rem;
      --grid-gap-desktop: 4px;
      --grid-gap-tablet: 3px;
      --grid-gap-mobile: 2px;
      --grid-min-tile-size: 140px;
      --grid-max-width: 1200px;
      --tile-border-radius: 4px;
      --transition-fast: 0.18s ease;
      --transition-normal: 0.25s ease;
      --transition-slow: 0.35s ease;
    }

    .photos.content{
      overscroll-behavior-y: contain;
      -webkit-tap-highlight-color: transparent;
      scroll-behavior: smooth;
    }
    @media (prefers-reduced-motion: reduce) {
      .photos.content{ scroll-behavior: auto; }
    }

    /* ====== Grid mit Container Query Support ====== */
    .photo-grid-wrapper{
      min-height: 60vh;
      position: relative;
      container-type: inline-size;
      container-name: photo-grid-wrapper;
    }
    .photo-grid{
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--grid-min-tile-size), 1fr));
      gap: var(--grid-gap-desktop);
      max-width: var(--grid-max-width);
      margin: 0 auto;
    }

    /* Fallback für ältere Browser */
    @media (max-width: 768px){ .photo-grid{ gap: var(--grid-gap-tablet); } }
    @media (max-width: 480px){ .photo-grid{ gap: var(--grid-gap-mobile); } }

    /* Container Queries (progressive enhancement) */
    @container photo-grid-wrapper (max-width: 768px) {
      .photo-grid{ gap: var(--grid-gap-tablet); }
    }
    @container photo-grid-wrapper (max-width: 480px) {
      .photo-grid{ gap: var(--grid-gap-mobile); }
    }

    /* ====== Tiles ====== */
    .photo-tile{
      position: relative;
      aspect-ratio: 1;
      overflow: hidden;
      background: #f3f4f6;
      cursor: pointer;
      transition: opacity var(--transition-normal), transform 0.1s ease, box-shadow var(--transition-fast);
      opacity: 0; /* wird durch .ready aufgehoben */
      border-radius: var(--tile-border-radius);
      content-visibility: auto;

      /* Fix: Intrinsische Größe für korrekte Lazy-Activation auch bei Sprüngen */
      contain-intrinsic-size: 220px 220px;
    }
    .photo-tile.ready{ opacity: 1; }
    .photo-tile.hidden{ display: none; }
    .photo-tile:active{ transform: scale(0.99); }

    .photo-tile img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transition: filter var(--transition-slow), transform var(--transition-slow), opacity var(--transition-slow);
    }
    .photo-tile img.lqip{
      filter: blur(12px);
      transform: scale(1.03);
      opacity: 0.9;
    }

    /* ====== Pill Basis ====== */
    .pill{
      background: rgba(17,24,39,.85);
      color:#fff;
      border:1px solid rgba(255,255,255,.12);
      border-radius: 9999px;
      padding:.62rem 1.12rem;
      font-size:1rem;
      line-height:1.1;
      backdrop-filter: blur(3px) saturate(120%);
      box-shadow:0 4px 16px rgba(0,0,0,.2);
      white-space:nowrap;
    }
    @media (pointer:coarse){
      .pill{ padding:.82rem 1.28rem; font-size:1.08rem; }
    }
    @media (prefers-color-scheme: light){
      .pill{ background: rgba(255,255,255,.95); color:#111827; border-color:#e5e7eb; }
    }

    /* ====== FIXED Datumspille (mit stabilem Top-Update) ====== */
    .month-badge{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: calc(var(--safe-top) + var(--badge-margin));
      z-index: 12;
      cursor: pointer;
      will-change: top; /* wichtig für ruckelfreies Clamping */
    }
    .month-badge.active{ box-shadow:0 0 0 3px rgba(59,130,246,.35); }

    /* ====== Year Rail ====== */
    .year-rail{
      position: fixed;
      top: var(--railTop, 64px);
      left: var(--railLeft, 0);
      width: var(--railWidth, 100%);
      z-index: 100;
      pointer-events:none;
    }
    .year-rail-strip{
      width:100%;
      background: rgba(0,0,0,.55);
      outline:1px solid rgba(255,255,255,.15);
      backdrop-filter: blur(2px);
      transform: scaleX(0.15);
      transform-origin: var(--anchorX, 50%) 50%;
      clip-path: inset(0 50% 0 50%);
      transition: transform .22s ease-out, clip-path .28s ease-out, opacity .18s ease-out;
      opacity: 0;
    }
    .year-rail.visible .year-rail-strip{
      pointer-events:auto;
      transform: scaleX(1);
      clip-path: inset(0 0 0 0);
      opacity: 1;
    }
    .year-row{
      display:flex; align-items:center; gap:.5rem;
      overflow-x:auto; -webkit-overflow-scrolling:touch; scrollbar-width:none;
      padding:.75rem 1rem;
    }
    .year-row::-webkit-scrollbar{ display:none; }
    .ypill{ cursor:pointer; opacity:0; transform: translateY(-6px); transition: opacity .22s ease, transform .22s ease; }
    .year-rail.visible .ypill{ opacity:1; transform: translateY(0); transition-delay: calc(var(--i,0) * 18ms); }
    .ypill[aria-pressed="true"]{ background:#3b82f6; border-color:#3b82f6; color:#fff; }

    /* ====== Hover/Fokus ====== */
    .photo-tile:focus-visible{ outline: 3px solid #3b82f6; outline-offset: 2px; }
    .photo-tile:hover{ box-shadow: 0 8px 28px rgba(0,0,0,.22); }
    .photo-tile:hover img{ transform: scale(1.03); }

    /* Overlay nur bei Caption */
    .photo-tile[data-has-caption="1"]::after{
      content: attr(data-caption);
      position:absolute; left:0; right:0; bottom:0;
      padding:.55rem .65rem;
      color:#fff; font-size:.82rem; line-height:1.25;
      opacity:0; transform: translateY(6px);
      transition: opacity .18s ease, transform .18s ease;
      background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.55) 65%, rgba(0,0,0,.7) 100%);
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      pointer-events:none;
    }
    .photo-tile[data-has-caption="1"]:hover::after,
    .photo-tile[data-has-caption="1"]:focus-visible::after{
      opacity:1; transform: translateY(0);
    }
    /* optional fürs Mobile-Vorschau-Feature (falls genutzt) */
    .photo-tile.show-caption[data-has-caption="1"]::after{
      opacity:1; transform: translateY(0);
    }

    /* Mini-Datum oben rechts – Hover/Fokus (Desktop) / Tap (Mobile) */
    .photo-tile .date-badge{
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      padding: 0.28rem 0.5rem;
      font-size: 0.75rem;
      line-height: 1;
      color: #fff;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 0.6rem;
      box-shadow: 0 2px 10px rgba(0,0,0,.18);
      opacity: 0;
      transform: translateY(-3px);
      transition: opacity var(--transition-fast), transform var(--transition-fast);
      pointer-events: none;
    }
    .photo-tile:hover .date-badge,
    .photo-tile:focus-visible .date-badge{
      opacity: 1;
      transform: translateY(0);
    }

    #infiniteSentinel{ height:2px; }
  </style>

  <div class="photo-grid-wrapper">
    <!-- Datumspille -->
    <button id="monthBadge" class="month-badge pill"
            aria-live="polite"
            aria-label="Aktueller Monat und Jahr. Klicken um Jahresübersicht zu öffnen"
            title="Jahre anzeigen"></button>

    <!-- Year Rail -->
    <nav id="yearRail" class="year-rail" aria-hidden="true" aria-label="Jahresnavigation">
      <div class="year-rail-strip">
        <div class="year-row" id="yearRow" role="tablist" aria-label="Jahresauswahl"></div>
      </div>
    </nav>

    <section class="photo-grid" id="photoGrid">
      {{ $pages := sort (where .Site.RegularPages "Type" "in" (slice "post" "photo")) "Date" "desc" }}
      {{ $imageIndex := 0 }}

      {{ range $p := $pages }}
        {{ $dateFormatted := $p.Date.Format "2. January 2006" }}
        {{ $dateISO := $p.Date.Format "2006-01-02" }}
        {{ $year := $p.Date.Format "2006" }}
        {{ $overlayCaption := "" }}
        {{ with $p.Title }}{{ $overlayCaption = . | plainify | truncate 80 }}{{ end }}

        {{ with $p.Params.photos }}
          {{ range $i, $url := . }}
            {{ $eager := lt $imageIndex 12 }}
            {{ $isMBPhotos := or (hasPrefix $url "https://micro.blog/photos/") (hasPrefix $url "http://micro.blog/photos/") }}
            {{ $src300 := "" }}{{ $src600 := "" }}{{ $srcFull := "" }}{{ $tiny := "" }}
            {{ if $isMBPhotos }}
              {{ $src300 = replaceRE `/photos/[^/]+/` "/photos/200x/" $url }}
              {{ $src600 = replaceRE `/photos/[^/]+/` "/photos/400x/" $url }}
              {{ $tiny = replaceRE `/photos/[^/]+/` "/photos/40x/" $url }}
              {{ $srcFull = $url }}
            {{ else }}
              {{ $encoded := $url | urlquery }}
              {{ $src300 = printf "https://micro.blog/photos/200x/%s" $encoded }}
              {{ $src600 = printf "https://micro.blog/photos/400x/%s" $encoded }}
              {{ $tiny = printf "https://micro.blog/photos/40x/%s" $encoded }}
              {{ $srcFull = $url }}
            {{ end }}

            {{ partial "photo-tile.html" (dict "srcFull" $srcFull "src300" $src300 "src600" $src600 "tiny" $tiny "caption" $overlayCaption "dateFormatted" $dateFormatted "dateISO" $dateISO "year" $year "permalink" $p.RelPermalink "index" $imageIndex "eager" $eager) }}
            {{ $imageIndex = add $imageIndex 1 }}
          {{ end }}
        {{ end }}

        {{ $imgs := $p.Resources.ByType "image" }}
        {{ range $img := $imgs }}
          {{ $name := $img.Name | lower }}
          {{ if not (or (hasPrefix $name "hero") (in $name "og-") (in $name "open-graph") (in $name "social") (in $name "thumb")) }}
            {{ $w300 := $img.Fit "200x200 q85" }}
            {{ $w600 := $img.Fit "400x400 q85" }}
            {{ $w40 := $img.Fit "40x40 q50" }}
            {{ $eager := lt $imageIndex 12 }}

            {{ partial "photo-tile.html" (dict "srcFull" $img.RelPermalink "src300" $w300.RelPermalink "src600" $w600.RelPermalink "tiny" $w40.RelPermalink "caption" $overlayCaption "dateFormatted" $dateFormatted "dateISO" $dateISO "year" $year "permalink" $p.RelPermalink "index" $imageIndex "eager" $eager) }}
            {{ $imageIndex = add $imageIndex 1 }}
          {{ end }}
        {{ end }}
      {{ end }}
    </section>
  </div>

  <div id="infiniteSentinel" aria-hidden="true"></div>

  <script>
    (function () {
      try {
        // ====== Performance-Konstanten ======
        const INITIAL_LOAD_COUNT = 36;
        const BATCH_SIZE = 36;
        const PREFETCH_AHEAD = 24;
        const INTERSECTION_ROOT_MARGIN = '1000px 0px';
        const SENTINEL_ROOT_MARGIN = '1200px 0px';
        const NEAR_BOTTOM_THRESHOLD = 900;
        const SCROLL_THROTTLE_MS = 180;
        const MOBILE_SCROLL_DEBOUNCE_MS = 160;
        const SCROLL_IDLE_UNLOCK_MS = 250;
        const CLAMP_THROTTLE_MS = 80;
        const CLAMP_TICK_TIMEOUT_MS = 120;
        const BADGE_HIDE_TIMEOUT_MS = 3000;
        const CLICK_SUPPRESS_MS = 450;
        const JUMP_BUFFER_BEFORE = BATCH_SIZE * 2;  // 72 Tiles beim Jahr-Sprung
        const JUMP_BUFFER_AFTER = BATCH_SIZE * 4;   // 144 Tiles beim Jahr-Sprung
        const MAX_VIRTUAL_WINDOW = BATCH_SIZE * 20; // Max 720 Tiles gleichzeitig

        // ====== DOM-Referenzen ======
        const grid        = document.getElementById('photoGrid');
        if (!grid) return;

        const allTiles    = Array.from(grid.querySelectorAll('.photo-tile'));
        const sentinel    = document.getElementById('infiniteSentinel');
        const monthBadge  = document.getElementById('monthBadge');
        const yearRail    = document.getElementById('yearRail');
        const yearStrip   = yearRail?.querySelector('.year-rail-strip');
        const yearRow     = document.getElementById('yearRow');
        const gridWrapper = document.querySelector('.photo-grid-wrapper');

        const params = new URLSearchParams(location.search);
        const fmtMonthYear = new Intl.DateTimeFormat('de-DE', { month: 'long', year: 'numeric' });
        const fmtShortDate = new Intl.DateTimeFormat('de-DE', { day:'numeric', month:'short', year:'numeric' });

        const years = Array.from(new Set(allTiles.map(t => t.dataset.year))).filter(Boolean).sort((a,b)=> b.localeCompare(a));

        // Virtual Scroll Range (statt nur visibleCount)
        let visibleRange = {
          start: 0,
          end: Math.min(allTiles.length, INITIAL_LOAD_COUNT)
        };
        const batchSize    = BATCH_SIZE;
        const prefetchAhead= PREFETCH_AHEAD;

        // requestIdleCallback Polyfill/Wrapper
        const scheduleIdleTask = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));
        const cancelIdleTask = window.cancelIdleCallback || clearTimeout;

        /* ====== Date-badges einmalig befüllen ====== */
        function hydrateDateBadges(){
          allTiles.forEach(t => {
            const iso = t.dataset.dateIso;
            const badge = t.querySelector('.date-badge');
            if (!badge || !iso) return;
            const d = new Date(iso + 'T00:00:00');
            badge.textContent = fmtShortDate.format(d);
          });
        }

        /* ====== URL-Sync (mit requestIdleCallback) ====== */
        let isProgrammaticScroll = false;
        let lastURLYear = null;
        let scrollIdleTimer = null;
        let urlSyncIdleTask = null;

        function syncURLToCurrentYear(){
          if (isProgrammaticScroll) return;
          const { year } = getCurrent();
          if (!year || year === lastURLYear) return;

          // URL-Update im Idle ausführen
          if (urlSyncIdleTask) cancelIdleTask(urlSyncIdleTask);
          urlSyncIdleTask = scheduleIdleTask(() => {
            const url = new URL(location.href);
            url.searchParams.set('year', year);
            history.replaceState(null, '', url);
            lastURLYear = year;
            urlSyncIdleTask = null;
          });
        }

        function scheduleUnlockAfterScrollIdle(){
          if (!isProgrammaticScroll) return;
          if (scrollIdleTimer) clearTimeout(scrollIdleTimer);
          scrollIdleTimer = setTimeout(()=>{ isProgrammaticScroll = false; syncURLToCurrentYear(); }, SCROLL_IDLE_UNLOCK_MS);
        }

        /* ====== Sichtbarkeit (Virtual Scroll) ====== */
        function applyVisibility(){
          allTiles.forEach((t, i) => {
            const inRange = i >= visibleRange.start && i < visibleRange.end;
            t.classList.toggle('hidden', !inRange);
          });
          hydrateVisibleImages();
          updateBadge();

          // Sichtbare Eager-Bilder sofort zeigen (Fail-safe)
          grid.querySelectorAll('.photo-tile:not(.hidden) img[src]:not([data-src])')
            .forEach(img => { img.closest('.photo-tile')?.classList.add('ready'); });
        }

        let prefetchIdleTask = null;
        function prefetchNext(){
          if (prefetchIdleTask) cancelIdleTask(prefetchIdleTask);

          prefetchIdleTask = scheduleIdleTask(() => {
            const start = visibleRange.end;
            const end   = Math.min(allTiles.length, visibleRange.end + prefetchAhead);
            for (let i = start; i < end; i++) {
              const img = allTiles[i]?.querySelector('img');
              if (img && img.dataset && !img.dataset.activated) {
                if (img.dataset.sizes && !img.sizes) img.sizes = img.dataset.sizes;
                if (img.dataset.srcset && !img.srcset) img.srcset = img.dataset.srcset;
              }
            }
            prefetchIdleTask = null;
          });
        }

        function loadMore() {
          const before = visibleRange.end;
          visibleRange.end = Math.min(allTiles.length, visibleRange.end + batchSize);
          if (visibleRange.end === before) return;
          applyVisibility();
          prefetchNext();
          syncURLToCurrentYear();
        }

        function loadBefore() {
          if (visibleRange.start === 0) return;
          const newStart = Math.max(0, visibleRange.start - batchSize);
          visibleRange.start = newStart;
          applyVisibility();
          syncURLToCurrentYear();
        }

        /* ====== Aktuelle Position (an der Pille) ====== */
        function getCurrent(){
          if (visibleRange.end === 0) return { year:'', label:'' };

          const badgeBottom = monthBadge.getBoundingClientRect().bottom + 4;
          let candidate = null, bestDelta = Infinity;

          for (let i = visibleRange.start; i < visibleRange.end; i++){
            const t = allTiles[i];
            if (!t || t.classList.contains('hidden')) continue;
            const r = t.getBoundingClientRect();
            const d = Math.abs(r.top - badgeBottom);
            if (r.top >= badgeBottom - 1) { candidate = t; break; }
            if (d < bestDelta) { bestDelta = d; candidate = t; }
          }

          const iso = candidate?.dataset.dateIso;
          if (iso){
            const d = new Date(iso + 'T00:00:00');
            return { year: candidate.dataset.year, label: fmtMonthYear.format(d) };
          }
          return { year:'', label:'' };
        }

        function updateBadge(){
          const { year, label } = getCurrent();
          monthBadge.textContent = (yearRail.classList.contains('visible') && year) ? year : (label || '');
        }

        /* ====== Hartes Clamping gegen Bounce in den Header ====== */
        function clampBadgeToGridTop(){
          const vv = window.visualViewport;
          const css = getComputedStyle(document.documentElement);

          const badgeMargin = parseFloat(css.getPropertyValue('--badge-margin')) || 0;
          const vvOffsetTop = vv ? vv.offsetTop : 0;
          const safeTopCSS  = parseFloat(css.getPropertyValue('--safe-top')) || 0;
          const minTopSafe  = Math.max(0, vvOffsetTop + safeTopCSS + badgeMargin);

          // Stop-Linie = Oberkante des Foto-Grids (+ minimaler Puffer)
          const gridRect    = gridWrapper.getBoundingClientRect();
          const STOP_PAD    = 2;
          const stopLine    = gridRect.top + STOP_PAD;

          const badgeH      = monthBadge.offsetHeight || 40;
          const viewportH   = vv ? vv.height : window.innerHeight;
          const maxTop      = viewportH - badgeH - 8;

          const desiredTop  = Math.min( Math.max(minTopSafe, stopLine), maxTop );

          monthBadge.style.top = desiredTop + 'px';
        }

        /* ====== Year Rail ====== */
        function buildYearRow(){
          const cur = getCurrent().year || years[0];
          yearRow.innerHTML = '';
          years.forEach((y, idx) => {
            const btn = document.createElement('button');
            btn.className = 'pill ypill';
            btn.textContent = y;
            btn.dataset.year = y;
            btn.setAttribute('aria-pressed', String(y === cur));
            btn.style.setProperty('--i', idx);
            yearRow.appendChild(btn);
          });
        }
        function setRailFrameToBadge(){
          const main     = document.querySelector('main.photos.content') || document.querySelector('main');
          const mainRect = main.getBoundingClientRect();
          const badgeRect= monthBadge.getBoundingClientRect();
          yearRail.style.setProperty('--railLeft',  mainRect.left + 'px');
          yearRail.style.setProperty('--railWidth', mainRect.width + 'px');
          const stripH = yearStrip?.getBoundingClientRect().height || badgeRect.height;
          const railTop = Math.round(badgeRect.top + (badgeRect.height - stripH)/2);
          yearRail.style.setProperty('--railTop', (isFinite(railTop) ? railTop : badgeRect.top) + 'px');
          const anchorX = Math.max(0, Math.min(mainRect.width, (badgeRect.left + badgeRect.width/2) - mainRect.left));
          yearStrip?.style.setProperty('--anchorX', anchorX + 'px');
        }
        function openRail(){
          buildYearRow();
          if (yearStrip) yearStrip.style.visibility='hidden';
          yearRail.classList.add('visible');
          requestAnimationFrame(()=>{
            setRailFrameToBadge();
            monthBadge.classList.add('active');
            yearRail.setAttribute('aria-hidden','false');
            const curYear = getCurrent().year || years[0];
            monthBadge.textContent = curYear;
            if (yearStrip) yearStrip.style.visibility='';
          });
        }
        function closeRail(){
          yearRail.classList.remove('visible');
          monthBadge.classList.remove('active');
          yearRail.setAttribute('aria-hidden','true');
          updateBadge();
        }
        monthBadge.addEventListener('click', (e)=>{
          e.stopPropagation();
          if (yearRail.classList.contains('visible')) closeRail();
          else openRail();
        });
        document.addEventListener('click', (e)=>{
          if (!yearRail.classList.contains('visible')) return;
          if (!yearRail.contains(e.target) && e.target !== monthBadge) closeRail();
        });
        yearRow.addEventListener('click', async (e)=>{
          const btn = e.target.closest('.ypill'); if (!btn) return;
          await scrollToYear(btn.dataset.year);
          closeRail();
        });

        async function scrollToYear(targetYear){
          const index = allTiles.findIndex(t => t.dataset.year === targetYear);
          if (index === -1) return;

          isProgrammaticScroll = true;

          // Virtual Scroll: Lade nur ein Fenster um das Ziel herum
          visibleRange.start = Math.max(0, index - JUMP_BUFFER_BEFORE);
          visibleRange.end = Math.min(allTiles.length, index + JUMP_BUFFER_AFTER);

          applyVisibility();

          // SOFORT Bilder im Zielbereich aktivieren, bevor wir scrollen
          // Dadurch starten sie mit dem Laden, während wir scrollen
          const viewportHeight = window.innerHeight;
          const estimatedTilesPerViewport = Math.ceil(viewportHeight / 140); // ~140px = min tile size
          const tilesToPreload = estimatedTilesPerViewport * 3; // 3 Viewports vorladen

          const preloadStart = Math.max(visibleRange.start, index);
          const preloadEnd = Math.min(visibleRange.end, index + tilesToPreload);

          for (let i = preloadStart; i < preloadEnd; i++) {
            const img = allTiles[i]?.querySelector('img[data-src]');
            if (img) activateImg(img);
          }

          await new Promise(r => requestAnimationFrame(r));

          // Prefetch für smooth scrolling
          prefetchNext();

          const anchor = allTiles[index];
          if (anchor && !anchor.classList.contains('hidden')) {
            const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            anchor.scrollIntoView({ behavior: reduce ? 'auto' : 'smooth', block: 'start' });
          }

          const url = new URL(location.href);
          url.searchParams.set('year', targetYear);
          history.replaceState(null, '', url);
          lastURLYear = targetYear;
          scheduleUnlockAfterScrollIdle();
        }

        window.addEventListener('popstate', () => {
          const sp = new URL(location.href).searchParams;
          const y = sp.get('year'); if (!y) return;
          isProgrammaticScroll = true;
          scrollToYear(y);
          scheduleUnlockAfterScrollIdle();
        });

        /* ====== Lazy ====== */
        function activateImg(img){
          if (!img || img.dataset.activated) return;
          if (img.dataset.sizes && !img.sizes) img.sizes = img.dataset.sizes;
          if (img.dataset.srcset && !img.srcset) { img.srcset = img.dataset.srcset; delete img.dataset.srcset; }
          if (img.dataset.src) { img.src = img.dataset.src; delete img.dataset.src; }
          img.dataset.activated = '1';
          img.addEventListener('load', function(){
            const t = img.closest('.photo-tile'); if (t) t.classList.add('ready');
            img.classList.remove('lqip');
          }, { once:true });
        }

        // Berechne Distanz eines Elements zum Viewport-Center
        function getViewportDistance(element) {
          const rect = element.getBoundingClientRect();
          const viewportCenter = window.innerHeight / 2;
          const elementCenter = rect.top + rect.height / 2;
          return Math.abs(elementCenter - viewportCenter);
        }

        // Finde Tiles die aktuell im erweiterten Viewport sind (optimiert)
        function getTilesInViewport(buffer = 2) {
          const viewportHeight = window.innerHeight;
          const viewportTop = 0;
          const viewportBottom = viewportHeight;
          const bufferZone = viewportHeight * buffer;

          const tilesInView = [];

          // Optimierung: Prüfe nur Tiles im aktuellen visibleRange + nahe Umgebung
          const searchStart = Math.max(0, visibleRange.start - 50);
          const searchEnd = Math.min(allTiles.length, visibleRange.end + 50);

          for (let i = searchStart; i < searchEnd; i++) {
            const tile = allTiles[i];
            const rect = tile.getBoundingClientRect();

            // Prüfe ob Tile im erweiterten Viewport ist
            if (rect.bottom > viewportTop - bufferZone && rect.top < viewportBottom + bufferZone) {
              tilesInView.push({
                tile,
                index: i,
                rect,
                distance: getViewportDistance(tile)
              });
            }
          }

          // Robuster Fallback: Binäre Suche wenn keine Tiles gefunden
          if (tilesInView.length === 0) {
            // Binäre Suche nach erstem sichtbaren Tile
            let left = 0;
            let right = allTiles.length - 1;
            let firstVisible = -1;

            while (left <= right) {
              const mid = Math.floor((left + right) / 2);
              const rect = allTiles[mid].getBoundingClientRect();

              if (rect.bottom > viewportTop - bufferZone) {
                firstVisible = mid;
                right = mid - 1; // Suche weiter links
              } else {
                left = mid + 1; // Suche rechts
              }
            }

            // Wenn gefunden, sammle alle sichtbaren Tiles in der Nähe
            if (firstVisible !== -1) {
              const scanStart = Math.max(0, firstVisible - 100);
              const scanEnd = Math.min(allTiles.length, firstVisible + 300);

              for (let j = scanStart; j < scanEnd; j++) {
                const t = allTiles[j];
                const r = t.getBoundingClientRect();
                if (r.bottom > viewportTop - bufferZone && r.top < viewportBottom + bufferZone) {
                  tilesInView.push({
                    tile: t,
                    index: j,
                    rect: r,
                    distance: getViewportDistance(t)
                  });
                }
              }
            }
          }

          return tilesInView;
        }

        // Aktualisiere visibleRange basierend auf aktueller Scroll-Position
        function updateVisibleRangeFromViewport() {
          const tilesInView = getTilesInViewport(2);

          if (tilesInView.length === 0) {
            // Garantierter Fallback: Schätze Position basierend auf Scroll-Verhältnis
            const scrollRatio = window.scrollY / Math.max(1, document.documentElement.scrollHeight - window.innerHeight);
            const estimatedIndex = Math.floor(scrollRatio * allTiles.length);
            const safeIndex = Math.max(0, Math.min(allTiles.length - 1, estimatedIndex));

            // Setze einen großzügigen Bereich um die geschätzte Position
            visibleRange.start = Math.max(0, safeIndex - BATCH_SIZE * 3);
            visibleRange.end = Math.min(allTiles.length, safeIndex + BATCH_SIZE * 5);
            return;
          }

          // Finde minimalen und maximalen Index
          const indices = tilesInView.map(t => t.index);
          const minIndex = Math.min(...indices);
          const maxIndex = Math.max(...indices);

          // Erweitere Range um den Viewport herum (nicht sequentiell!)
          const bufferBefore = BATCH_SIZE;
          const bufferAfter = BATCH_SIZE * 2;

          const newStart = Math.max(0, minIndex - bufferBefore);
          const newEnd = Math.min(allTiles.length, maxIndex + bufferAfter);

          // Begrenze die Gesamtanzahl sichtbarer Tiles
          const rangeSize = newEnd - newStart;
          if (rangeSize > MAX_VIRTUAL_WINDOW) {
            // Zentriere das Fenster um den Viewport
            const center = Math.floor((minIndex + maxIndex) / 2);
            visibleRange.start = Math.max(0, center - Math.floor(MAX_VIRTUAL_WINDOW / 2));
            visibleRange.end = Math.min(allTiles.length, visibleRange.start + MAX_VIRTUAL_WINDOW);
          } else {
            visibleRange.start = newStart;
            visibleRange.end = newEnd;
          }
        }

        function hydrateVisibleImages(){
          // Hole ALLE Tiles die im Viewport oder nahe dran sind (egal ob hidden oder nicht)
          const tilesInView = getTilesInViewport(1.5);

          // Sammle alle Bilder aus diesen Tiles
          const imagesToLoad = tilesInView
            .map(item => {
              const img = item.tile.querySelector('img[data-src]');
              return img ? { img, distance: item.distance, tile: item.tile } : null;
            })
            .filter(Boolean)
            .sort((a, b) => a.distance - b.distance);

          // Lade Bilder in priorisierter Reihenfolge (nähere zuerst)
          imagesToLoad.forEach(item => activateImg(item.img));
        }
        if ('IntersectionObserver' in window) {
          const io = new IntersectionObserver((entries)=>{
            entries.forEach(entry=>{
              if (entry.isIntersecting) activateImg(entry.target);
            });
          }, { rootMargin: INTERSECTION_ROOT_MARGIN });
          grid.querySelectorAll('img[data-src]').forEach(img => io.observe(img));
        }

        /* ====== Infinite Scroll ====== */
        const sentinelIO = new IntersectionObserver((entries)=>{
          for (const e of entries) {
            if (e.isIntersecting) {
              loadMore();
              requestAnimationFrame(()=> loadMore());
            }
          }
        }, { rootMargin: SENTINEL_ROOT_MARGIN });
        sentinelIO.observe(sentinel);

        function nearBottom(px = NEAR_BOTTOM_THRESHOLD){
          const doc = document.documentElement;
          return (window.innerHeight + window.scrollY) >= (doc.scrollHeight - px);
        }

        function nearTop(px = NEAR_BOTTOM_THRESHOLD){
          return window.scrollY <= px;
        }

        /* ====== Navigation-Handler ====== */
        function go(tile){
          const url = tile?.dataset?.url;
          if (url) window.location.href = url;
        }
        const isTouch = 'ontouchstart' in window;

        // Desktop: Klick + Tastatur mit Pfeiltasten-Navigation
        if (!isTouch) {
          const GRID_COLS = getComputedStyle(grid).gridTemplateColumns.split(' ').length;

          allTiles.forEach(tile => {
            tile.addEventListener('click', (e)=> {
              if (tile._suppressNextClick) {
                tile._suppressNextClick = false;
                e.preventDefault();
                return;
              }
              go(tile);
            });

            tile.addEventListener('keydown', (e)=>{
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                go(tile);
                return;
              }

              // Pfeiltasten-Navigation
              const currentIndex = allTiles.indexOf(tile);
              let targetIndex = -1;

              switch(e.key) {
                case 'ArrowRight':
                  targetIndex = currentIndex + 1;
                  break;
                case 'ArrowLeft':
                  targetIndex = currentIndex - 1;
                  break;
                case 'ArrowDown':
                  targetIndex = currentIndex + GRID_COLS;
                  break;
                case 'ArrowUp':
                  targetIndex = currentIndex - GRID_COLS;
                  break;
                case 'Home':
                  targetIndex = 0;
                  break;
                case 'End':
                  targetIndex = allTiles.length - 1;
                  break;
                default:
                  return;
              }

              if (targetIndex >= 0 && targetIndex < allTiles.length) {
                e.preventDefault();
                const targetTile = allTiles[targetIndex];
                if (targetTile && !targetTile.classList.contains('hidden')) {
                  targetTile.focus();
                  targetTile.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              }
            });
          });
        }

        /* ====== Mobile: Arm-to-open (optimiert) ====== */
        if (isTouch) {
          const showPreview = (tile) => {
            const badge = tile.querySelector('.date-badge');
            if (badge) {
              badge.style.opacity = '1';
              badge.style.transform = 'translateY(0)';
            }
            if (tile.dataset.hasCaption === '1') {
              tile.classList.add('show-caption');
            }
          };

          const hidePreview = (tile) => {
            const badge = tile.querySelector('.date-badge');
            if (badge) {
              badge.style.opacity = '0';
              badge.style.transform = 'translateY(-3px)';
            }
            tile.classList.remove('show-caption');
            tile._armedOpen = false;
          };

          allTiles.forEach(tile => {
            tile._armedOpen = false;
            tile._hideTimer = null;

            tile.addEventListener('touchstart', () => {
              if (tile._armedOpen) {
                go(tile);
                return;
              }

              showPreview(tile);
              clearTimeout(tile._hideTimer);
              tile._hideTimer = setTimeout(() => hidePreview(tile), BADGE_HIDE_TIMEOUT_MS);
              tile._armedOpen = true;
              tile._suppressNextClick = true;
              setTimeout(() => tile._suppressNextClick = false, CLICK_SUPPRESS_MS);
            }, { passive: true });

            tile.addEventListener('click', (e) => {
              if (tile._suppressNextClick) {
                e.preventDefault();
                e.stopPropagation();
                tile._suppressNextClick = false;
                return;
              }
              go(tile);
            });
          });
        }

        /* ====== Konsolidierter Scroll-Handler (Performance-Optimiert) ====== */
        const isMobileUA = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        let scrollState = {
          ticking: false,
          lastClamp: 0,
          timeout: null,
          clampTicking: false,
          lastScrollTS: 0,
          loadMoreScheduled: false,
          loadBeforeScheduled: false,
          lastScrollY: window.scrollY,
          lastScrollCheck: performance.now(),
          velocity: 0
        };

        // Aggressive Bild-Aktivierung bei schnellem Scrollen
        function eagerLoadOnFastScroll() {
          const velocity = Math.abs(scrollState.velocity);
          const VELOCITY_THRESHOLD = 800; // px/s

          if (velocity < VELOCITY_THRESHOLD) return;

          // Bei schnellem Scrollen: Lade mehr Bilder in Scroll-Richtung voraus
          const scrollingDown = scrollState.velocity > 0;
          const viewportHeight = window.innerHeight;
          const estimatedTilesPerViewport = Math.ceil(viewportHeight / 140);

          // Je schneller, desto mehr vorladen (2-5 Viewports)
          const velocityFactor = Math.min(5, Math.ceil(velocity / VELOCITY_THRESHOLD));
          const tilesToPreload = estimatedTilesPerViewport * velocityFactor;

          // Finde Tiles in Scroll-Richtung, die noch nicht geladen sind
          const tilesInView = getTilesInViewport(velocityFactor);

          // Sammle Bilder basierend auf Scroll-Richtung
          const imagesToLoad = tilesInView
            .filter(item => {
              const img = item.tile.querySelector('img[data-src]');
              if (!img) return false;

              // Bei schnellem Scrollen: Priorisiere Richtung
              if (scrollingDown) {
                return item.rect.top > -viewportHeight;
              } else {
                return item.rect.bottom < viewportHeight * 2;
              }
            })
            .map(item => {
              const img = item.tile.querySelector('img[data-src]');
              return { img, distance: item.distance, tile: item.tile };
            })
            .filter(item => item.img)
            .sort((a, b) => a.distance - b.distance)
            .slice(0, tilesToPreload);

          // Aktiviere Bilder
          imagesToLoad.forEach(item => activateImg(item.img));
        }

        // Zentrale Scroll-Update Funktion
        function performScrollUpdates() {
          const now = performance.now();

          // Badge-Clamping (gedrosselt für Desktop)
          if (!isMobileUA && (now - scrollState.lastClamp > CLAMP_THROTTLE_MS)) {
            clampBadgeToGridTop();
            scrollState.lastClamp = now;
          }

          // Viewport-basierte Range-Updates (nur bei normalem Scrollen)
          if (!isProgrammaticScroll) {
            updateVisibleRangeFromViewport();
            applyVisibility();
          }

          // Weitere Updates
          if (!isMobileUA) {
            updateBadge();
            if (yearRail.classList.contains('visible')) setRailFrameToBadge();
            if (isProgrammaticScroll) scheduleUnlockAfterScrollIdle();
            else syncURLToCurrentYear();
            hydrateVisibleImages();
          }
        }

        // Haupt Scroll-Handler
        function onScroll() {
          // Scrollgeschwindigkeit messen
          const now = performance.now();
          const currentScrollY = window.scrollY;
          const deltaY = currentScrollY - scrollState.lastScrollY;
          const deltaTime = now - scrollState.lastScrollCheck;

          if (deltaTime > 0) {
            // Velocity in px/s
            scrollState.velocity = (deltaY / deltaTime) * 1000;
          }

          scrollState.lastScrollY = currentScrollY;
          scrollState.lastScrollCheck = now;

          // Sofortiges Clamping gegen Bounce
          clampBadgeToGridTop();

          // Bei schnellem Scrollen: Aggressive Vorlade-Strategie
          if (!isProgrammaticScroll) {
            eagerLoadOnFastScroll();
          }

          // Bidirektionales Laden nur bei sequentiellem Scrollen an den Rändern
          if (nearBottom()) {
            if (!scrollState.loadMoreScheduled) {
              scrollState.loadMoreScheduled = true;
              loadMore();
              setTimeout(() => scrollState.loadMoreScheduled = false, SCROLL_THROTTLE_MS);
            }
          }

          if (nearTop() && visibleRange.start > 0) {
            if (!scrollState.loadBeforeScheduled) {
              scrollState.loadBeforeScheduled = true;
              loadBefore();
              setTimeout(() => scrollState.loadBeforeScheduled = false, SCROLL_THROTTLE_MS);
            }
          }

          // Mobile: Debounced Updates
          if (isMobileUA) {
            if (scrollState.timeout) clearTimeout(scrollState.timeout);
            scrollState.timeout = setTimeout(() => {
              // Viewport-basierte Range-Updates
              if (!isProgrammaticScroll) {
                updateVisibleRangeFromViewport();
                applyVisibility();
              }
              updateBadge();
              if (yearRail.classList.contains('visible')) setRailFrameToBadge();
              if (isProgrammaticScroll) scheduleUnlockAfterScrollIdle();
              else syncURLToCurrentYear();
              hydrateVisibleImages();
            }, MOBILE_SCROLL_DEBOUNCE_MS);
          }
          // Desktop: rAF-basiert
          else {
            if (scrollState.ticking) return;
            scrollState.ticking = true;
            requestAnimationFrame(() => {
              performScrollUpdates();
              scrollState.ticking = false;
            });
          }

          // Clamp-Ticker aktivieren
          scrollState.lastScrollTS = performance.now();
          if (!scrollState.clampTicking) {
            scrollState.clampTicking = true;
            requestAnimationFrame(function tick() {
              if (!scrollState.clampTicking) return;
              clampBadgeToGridTop();
              if (performance.now() - scrollState.lastScrollTS > CLAMP_TICK_TIMEOUT_MS) {
                scrollState.clampTicking = false;
                return;
              }
              requestAnimationFrame(tick);
            });
          }
        }

        // Event Listeners (konsolidiert)
        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', onScroll, { passive: true });
        window.addEventListener('wheel', clampBadgeToGridTop, { passive: true });
        window.addEventListener('touchstart', clampBadgeToGridTop, { passive: true });
        window.addEventListener('touchmove', clampBadgeToGridTop, { passive: true });

        if (window.visualViewport) {
          window.visualViewport.addEventListener('scroll', clampBadgeToGridTop, { passive: true });
          window.visualViewport.addEventListener('resize', clampBadgeToGridTop, { passive: true });
        }

        /* ====== Initial ====== */
        applyVisibility();
        clampBadgeToGridTop();

        // Eager-Bilder sofort zeigen
        grid.querySelectorAll('img[src]:not([data-src])')
          .forEach(img => { img.closest('.photo-tile')?.classList.add('ready'); });

        const init = getCurrent();
        lastURLYear = init.year || lastURLYear;

        // Nicht-kritische Initialisierung im Idle
        scheduleIdleTask(() => {
          hydrateDateBadges();
          prefetchNext();
          syncURLToCurrentYear();
        });

        requestAnimationFrame(async () => {
          const y = params.get('year');
          if (y) await scrollToYear(y);
        });
      } catch(err){
        console.error('photos page init error', err);
        try { document.querySelectorAll('.photo-tile').forEach(t => t.classList.add('ready')); } catch {}
      }
    })();
  </script>
</main>
{{ end }}